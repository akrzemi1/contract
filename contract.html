<html>
<head></head>
<body>


<h1>What do we need?</h1>

<p>The 'features' we describe here can be collectively called <em>value constraints.</em> We want to use them to put some <em>constraints</em> into the program that cannot be handled by the current C++ type system.</p>
<h2>Specify function's domain</h2>
<p>The problem goes back to mathematics. Certain functions are well defined only for a subset of values of the input type. for instance a square root over real numbers is not defined for negative numbers. What does it mean for a function in a programming language like C++ that it is not defined? Currently there are two approaches. One is to detect the value of the parameter(s) that the function should not be prepared for and execute a different logic: returning a special value, throwing an exception, etc. Using our example with a square root, a corresponding function <code>sqrt()</code> could be defined as follows:</p>

<pre>double sqrt(double x)
{
  if (x &gt;= 0.0) {
    //<em> do proper algorithm</em>
  }
  else {
    return numeric_limits&lt;double&gt;::signaling_NaN();
    // <em>or throw an exception</em>
  }
}
</pre>

<p>What it effectively does is that such functions do not restrict their domain. They are well defined for every value of an input type, and do other things than only "proper algorithms". This means that our function can be used for detecting negative numbers:
</p>

<pre>double is_negative(double x)
{
  return isnan(sqrt(x));
}
</pre>

<p>Another way of approaching the function domain problem is to informally 'announce' that the function is not defined for certain values of input types and implement it with the assumption that the undesired values are never passed to the function:</p>

<pre>
double sqrt(double x)
{
  // proper algorithm:
  double y = 1.0;
  double prev_y;
 
  do {
    prev_y = y;
    y = (y + x / y) * 0.5;
  }
  while (!closeEnough(y, prev_y));
 
  return y;
}
</pre>

<p>This uses Newton's Iteration algorithm. The loop will terminate when values <code>y</code> and <code>prev_y</code> become close enough. They will only do that when <code>x</code> is non-negative. Supplying a negative value will make the loop run forever and hang the program. Even a clever analyser is unlikely to detect from the function body that passing a negative input to this function is something wrong. But everything is fine as long as no negative number is passed in. 'Announcing' that the function is not prepared for just any input is informal: it is either written in the comment, or in paper or html documentation, or only spread by word, or assumed to be obvious. This is risks an unintended negative program behaviour, like a halt, or a UB. However, it is often preferred because of performance and inability to come up with a reasonable fall-back action. Consider <code>std::vector::operator[]</code>, it does not check the bounds for performance reasons. If it was used in the following code:</p>

<pre>
for (int i = 0; i != vec.size(); ++i) {
  if (i &gt; 0) cout &lt;&lt; ", ";
  cout &lt;&lt; vec[i];
}
</pre>

<p>The condition in the loop already checks if the index is within bounds. If <code>operator[]</code> was also checking the same condition inside, we would be wasting time on doing redundant checks. Also, for some functions it is not possible to think of any fall-back action. For instance <code>std::vector::swap</code> must not throw exceptions and returns <code>void</code>, yet, it is not well defined when two vectors' allocators do not compare equal.</p>

<p>Not checking for argument being within domain and delegating the check to the callers is desirable, especially that the caller is in a better position in verifying if the domain of the function. Consider:</p>

<pre>return sqrt(abs(x));</pre>

<p>The caller can be sure that no negative value is passed to function <code>sqrt()</code> even though no check is performed at all. Function domain defined this way is a <em>contract</em> between function author and function callers. The author defines the domain and assumes he will not get values from outside the domain. The caller guarantees that she will not put pass values outside the domain. Out of all contracts described here, this one is the most likely to be broken, because it is the only one where the person responsible for guaranteeing it is different than the person declaring the contract. The user may not be aware that a function has requirements on the values of parameters, or may misunderstand what the requirement is. Therefore this contract requires the most serious attention and support in the language.</p>

<p>What we need is the ability to declare the function's domain along with the function, so that it is visible to the callers and to the automated tools. How the tools can handle this is a secondary issue, but the behaviour can be: (1) automated documentation generation, (2) additional warnings from static analysers, (3) additional instrumentation injected by compilers, (4) compiler optimizations based on domain declarations.</p>

<h2>Specify function's co-domain</h2>

<p>In the above example with function <code>abs()</code> a hypothetical tool could detect that expression <code>sqrt(abs(x))</code> is always fine only if it knew that the co-domain of <code>abs</code> is equal (or smaller) than the domain of <code>sqrt</code>. We need to be able to constrain the allowed function output in order for automated tools to be able to verify if other functions' domain requirements are satisfied. </p>

<p>In this case a function author specifies the contract and (likely) the same author guarantees it. Function's user can rely on the guarantee. It is much less likely that this contract is broken, because it is the same person that declares and later ensures the obligation. And conversely, if the author makes an error in the function, he is equally likely to make an error in specifying the contract.</p>


<h2>Block-level assertions</h2>

<p>This type of value constraint is quite familiar to many C++ user, as it is implemented with macro <code>assert</code> and some similar tools in many libraries. If we think of it as a contract, this time a function author defines it, he ensures that it holds, and he is the benefactor of the contract: he guarantees something to himself, namely that certain state of a block-local variable or set of variables shall never occur at the point of the assertion. At the same time the function author guarantees something that he can be held accountable for, and relies on the guarantee expressed with the assertion.</p>

<h2>Class-level assertions</h2>

<p>A similar constraint on variables is often required for (non-static) data members of objects of a given class. Consider the following example:</p>

<pre>class WeighedAverage
{
  double wgt1_ = 0.5;
  double wgt2_ = 0.5;
public:
  double average(double val1, double val2) const; 
  <em>// ensures: answer is between val1 and val2</em>
  { return wgt1_ * val1 + wgt2_ * val2; }

  void set_1st_weight(double w1); 
  <em>// requires: w1 between 0.0 and 1.0</em>
  { wgt1_ = w1; wgt2_ = 1.0 - w1; }

  <em>// always true: wgt1_ between 0.0 and 1.0</em>
  <em>// always true: wgt2_ between 0.0 and 1.0</em>
  <em>// always true: wgt1_ + wgt2_ == 1.0</em>
};
</pre>

<p>Note the three comments at the bottom. They are something that could be expressed with macro <code>assert</code>, except that <code>assert</code> is an expression and cannot be put at the class scope. Note also that members <code>wgt1_</code> and <code>wgt2_</code> are private. So, we are not declaring anything to the outside world. Word "always" needs to be more formal. It applies to any object of this class whose life time has begun and have not yet ended, except that member functions can temporarily compromise it provided that they restore it upon exit (either via exception or a normal return). Also, in case of thread or context switching, if a function decides to temporarily break such class-scope assertion, it must guard this action with a lock or equivalent, so that other threads do not see an object with a broken contract.</p>


<h2>Specify equivalent expressions</h2>


<p>Often library interfaces offer more than one way of doing the same thing. For instance, checking if a container contains at least two elements can be checked in two ways: <code>cont.empty()</code> and <code>cont.size() != 0</code>. The latter is more general and could be used to check for emptiness, but there are occasions where the former can perform faster. This justifies the existence of the two forms. However, the job of matching one function's domain with other function's co-domain would be severely impeded if either specified the contract with a different (albeit equivalent expression. consider:</p>

<pre>template &lt;typename T&gt;
class vector
{
  void resize (size_t s); <em>// ensures: this->size() == s</em>
  const T&amp; front() const; <em>// requires: !this->empty()</em>
};

vec.resize(1);
return vec.front();       <em>// safe?</em>
</pre>

<p>Can we match what <code>resize</code> guarantees with what <code>front</code> expects? The two expressions are different. It would be much easier if we were able to explicitly declare that for any container expressions <code>cont.empty()</code> and <code>cont.size() != 0</code> are equivalent. This is somewhat similar to class-level assertions, but the declaration applies to more than one class, now we are only interested in the public interfaces, and we can express equivalence between expressions that have side effects. for instance, we can specify that <code>cont.clear()</code> is equivalent to <code>cont.resize(0)</code>. Out of all "constraints" described in this section, this is the only one where term "value constraint" is inadequate. This is a constraint on the semantics of expressions.</p>

<h2>Loop variants</h2>

<p>This is somewhat similar to an assertion. It can help convince oneself that a non-trivial loop will ultimately terminate. Sometimes it is not easily seen, because there is no loop counter. We may for instance inspect elements in the collection by skipping some elements, increasing or shrinking, the collection. A loop variant is an expression that evaluates to an integral non-negative number. It is expected that in each loop iteration evaluating this expression renders a number smaller than in the previous iteration. It is also expected that when the value renders zero, the loop terminates.</p>

<p>A framework for supporting value constraints need not address all the above needs. We believe that only supporting the declaration of function domain is a big help in itself. Note that while assertions loop variants need to work with expressions, the features for specifying function domain and co-domain need not necessarily use expressions. We address this in detail in the later sections.</p>



<h1>What use can be made of value constraints?</h1>

<p>Value constraints exist, even though there is no language support for them in the language. We have seen in the above examples that comments were used to convey the information. In this section we list the benefits obtained form standardizing or formalizing value constraints this way or the other.</p>

<p>In order for an automated tool to understand the constraint, we have to provide a special-purpose syntax. Some tools expect that it is put inside source code comments. For instance [ACSL] uses the following notation: </p>
<pre><em>/*@ requires x >= 0;
    ensures \result >= 0; 
*/</em>
double sqrt(double x);</pre>

<p>But for structured comments like the above, C++ has an alternative: [[attributes]]. Attributes are akin to comments because they cannot affect the semantics of the program. On the other hand they can be used as hints for optimizations, warnings and any kind of program analysis. If the expectation of value constraints is to affect the program behaviour, attributes will not do, and a special language feature would need to be devised.</p> 

<p>An ideal &mdash; and unrealistic &mdash; support for value constraints is for compiler to check any possible flow in the program and signal a compiler error whenever a breach of the constraint is going to happen. Because this is not doable, the we aim at the support that is not entirely satisfactory, but believed to be better than none.</p>

<h2>Improved documentation</h2>

<p>One of the obvious uses of formalized value constraints is the automated generation of documentation. Even if developers do not use any tool for generating documentation, there is still a gain. When a developer sees the declaration of the function she is going to use, she can immediately see the value constraints along. If they are a language feature, developers are more encouraged to use them (even though comments would do). Since this does not affect program semantics [[attributes]] are sufficient.</p>

<h2>Static analysis</h2>

<p>Value constraints could enable static analysers to detect a potential breach of value constraints and issue warnings. Again, using value constraints this way does not affect program semantics, so [[attributes]] would do.</p>

<h2>Constraint-based compiler optimizations</h2>

<p>In that case, compiler is able to arbitrarily change the behaviour of the program in case where a value constraint has been violated. So, adding a value constraint may change the meaning of the program. In this case attributes will not suffice, and we need a language extension for specifying value constraints.</p>

<h2>Auto-generation of runtime checks</h2>

<p>This is what Eiffel provides and what [N1962] proposes. Value constraints need to be C++ expressions. An implementation can (optionally) inject, at well defined places, a code that evaluates at run-time expressions representing value constraints. If any (boolean) expression evaluates to <code>false</code>, a certain action (like calling <code>std::terminate</code>) is performed. The insertion of additional logic requires that value constraints are introduced as a language feature. In fact even more language and library features is required to control when and how the run-time checks are performed and responded to.</p>


<h1>Run-time evaluation of value constraints</h1>

<p>In this section we focus on one possible approach: treating value constraints as expressions and evaluating them at run-time.</p>

<h2>Side effects of the expressions</h2>

<p>Using expressions with side effects in value constraints is generally discouraged, but sometimes it might be difficult to spot that we have a side effect. For the purpose of this discussion we also consider run-time overhead, and especially the run-time complexity as a side effect. To minimize the possibility of invoking a function with a side effect [N1962] proposes that only <code>const</code>-qualified member functions are allowed; but even these can modify non-member variables, and it is not only member functions that may need to be used to express value constraints. Ideally, we would like to use only <em>pure</em> (referentially transparent) expressions, but C++ as of today does not offer the possibility of detecting if an expression is pure. Although the definition of relaxed <code>constexpr</code> functions makes a step towards pure functions.</p>

<p>A practical question to be answered, given the syntax from [N1962], is if the following to be a legal code for detecting if run-time value constraint checks are enabled?</p>

<pre>
int preconditions_on = false;
void test() precondition{ preconditions_on = true; }
{
  cout &lt;&lt; "preconditions are on: " &lt;&lt; preconditions_on;
}
</pre>

<p>And similarly, is the following a reliable way of checking if a number is negative?</p>

<pre>double sqrt(double x) precondition { x >= 0.0; };

double is_negative(double x)
{
  set_precondition_broken_handler(&amp;throw_exception);
  try { sqrt(x) };
  catch (exception const&amp;) { return true; }
  return false;
}
</pre>

<h2>Value constraints in overloaded functions</h2>

<p>Consider the following declaration:</p>

<pre>
template &lt;typename IIT&gt; <em>// requires: InputIterator&lt;IIT&gt;</em>
void displayFirstSecondNext(IIT beg, IIT end);
<em>// requires: std::distance(beg, end) &gt;=2</em>
</pre>

<p>Is function template <code>std::distance</code> referentially transparent? The answer is: it is not templates that can or cannot be pure but functions. Some functions instantiated from this template will be pure, others will not &mdash; it depends what iterator type the template will be instantiated with. Consider <code>InputIterator</code>. In the worst case (of <code>std::istream_iterator</code>) incrementing the iterator invalidates other iterators referring to the same stream. This is a tricky behaviour: by changing our internal copies of objects (iterators), we alter (invalidate) other, external objects. Function <code>std::distance</code> does increment iterators. If our precondition was to be evaluated, this might cause a UB in the program.</p>

<p>Thus, we have an expression; it is pure and natural to use for some instantiations, and has severe side effects for other instantiations. If we want it to be evaluated only in certain instantiations, another feature needs to be provided. For instance, we will need to specialize a template only to be able to specify a different precondition, or add an annotation that this precondition should not be evaluated if certain compile-time predicate evaluates to <code>true</code>. clearly, on global switch (similar to <code>NDEBUG</code>) saying "disable/enable all value constraint evaluations" will not be enough.</p>

<h2>Inadvertent increase in run-time complexity</h2>
<p>There are other reasons for having a more fine grained control of which checks should be enabled. Consider a binary search algorithm. Its runtime complexity is O(log <var>n</var>). It has an obvious precondition that the range we search through is sorted. Performing the sorted check has complexity O(<var>n</var>). Thus by evaluating the precondition, we change the algorithms complexity. This might be unacceptable, even for some debug/testing builds. Runtime complexity is a sort of side effect of an algorithm, and it can be silently added to the function, especially when following a good practise a developer adds an obvious precondition, which would be his primary task, and forgets the secondary task of specifying (using some contract-specific sub-language) the conditions under which this precondition shall be evaluated.</p>

<h2>Run-time response to a broken contract</h2>

<p>[N1962] proposes that the action taken upon violating a value constraint should be configurable by the programmer. While we agree this should be configurable, we object to the way of achieving this by <code>std::set_terminate</code>-like registering function. <code>std::set_terminate</code> can be called multiple times from multiple places: different, possibly dynamically-loaded/shared libraries. This makes sense for <code>std::terminate</code>. Every part of the system may acquire a <em>critical</em> resource: one that has to be released even if "exception handling must be abandoned for less subtle error handling techniques". In that case the component also needs to register an additional clean-up function. In case of broken contract situation, we do not need or want that. We believe only the person that assembles the final program from the components and libraries, should be empowered to to decide how broken contracts are handled. Only him does have the knowledge if this is a test or a retail build; if the slow-down of some run-time checks can be afforded. Libraries do not know that: they do not know in what environment they will be used.</p>

<p>Additionally, the <code>std::set_terminate</code> mechanism has a certain flow. Unless you apply some syntactic contortions, you cannot set the handler for functions executed before <code>main()</code>.</p>

<p>We are not aware of any mechanism currently available in C++ that would facilitate our needs. But since function <code>main</code> has the property of being required to be defined only once across the executable program, a solution we are leaning towards is to apply some special annotation around function <code>main</code> that would indicate what the user's preference is on the handling of broken contracts.</p>


<hr />

<h1>Do we need to standardize anything?</h1>




<hr />
avoid giving up control while in an inconsistent state either by calling out, returning, throwing, task switching, etc.<br>
mention psychological arguments
mention structured comments
<hr />

<p>ACSL: http://frama-c.com/download/acsl_1.4.pdf</p>
<p>Can a static analyzer do without pre- post- conditions? -- no, we do not know whose fault.</p>

<p>In this paper we want to change a focus from how broken contracts are responded to in run-time, to how contract violations can be detected at compile-time. What is needed in the language to help such static analysis; and what needs to be standardised as opposed to what should be provided by implementations as "quality of implementation".</p>



<pre>bool is_sorted(iter i, iter j);

void sort(iter i, iter j)
postcondition{ is_sorted(i, j) };

bool binary_search(iter i, iter j);
precondition{ is_sorted(i, j) };
</pre>
 

<pre>bool find(iter i, iter j)
precondition{ is_sorted(i, j) }
{
  return binary_search(i, j);
}

bool find(iter i, iter j)
precondition{ true }
{
  sort(i, j);
  return binary_search(i, j);
}
</pre>


http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1962.html
</body>
</html>
